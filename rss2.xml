<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>김기현 블로그</title>
    <link>https://kihyunkimlee.github.io/</link>
    
    <atom:link href="https://kihyunkimlee.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Mon, 26 Apr 2021 06:50:12 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[프로그래머스] 동굴 탐험</title>
      <link>https://kihyunkimlee.github.io/2021/04/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%8F%99%EA%B5%B4-%ED%83%90%ED%97%98/</link>
      <guid>https://kihyunkimlee.github.io/2021/04/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%8F%99%EA%B5%B4-%ED%83%90%ED%97%98/</guid>
      <pubDate>Sat, 24 Apr 2021 05:45:30 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;문제를-읽고-나서-알아차려야-했던-것들-3가지&quot;&gt;&lt;a href=&quot;#문제를-읽고-나서-알아차려야-했던-것들-3가지&quot; class=&quot;headerlink&quot; title=&quot;문제를 읽고 나서 알아차려야 했던 것들 3가지&quot;&gt;&lt;/a&gt;문제를 읽고 나서 알</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="문제를-읽고-나서-알아차려야-했던-것들-3가지"><a href="#문제를-읽고-나서-알아차려야-했던-것들-3가지" class="headerlink" title="문제를 읽고 나서 알아차려야 했던 것들 3가지"></a>문제를 읽고 나서 알아차려야 했던 것들 3가지</h2><p>문제 해결을 위해서 문제를 읽고 나서 알아차려야 했던 것들이 있다.   </p><h3 id="1-동굴은-트리-모양으로-되어있다"><a href="#1-동굴은-트리-모양으로-되어있다" class="headerlink" title="1. 동굴은 트리 모양으로 되어있다."></a>1. 동굴은 트리 모양으로 되어있다.</h3><p>문제에는 동굴이 트리 모양이라고 직접적으로 명시되어있지 않다.<br>하지만 문제를 읽어보면 다음과 같은 조건을 찾을 수 있다.   </p><ul><li>방의 개수가 n개일 때 방과 방 사이를 연결하는 통로의 개수는 n-1개이다(문제의 제한사항에 나와 있다).</li><li>임의의 서로 다른 두 방을 연결하는 최단 경로는 딱 한 가지만 있으며, 두 방 사이에 이동이 불가능한 경우는 없다.</li></ul><p>방의 개수가 n개이고 방과 방 사이를 연결하는 통로의 개수가 n-1개이므로 동굴이 트리 모양이라고 확신할 수 있을까…?<br>정답은 <u><strong>확신할 수 없다</strong></u>이다.<br>트리의 정의가 정점의 개수가 n개이고 간선의 개수가 n-1개인, 사이클이 존재하지 않는 그래프인 건 맞다.<br>하지만 정점의 개수가 n개이고 간선의 개수가 n-1개인 그래프가 항상 트리인 것은 아니다.<br>왜냐하면 아래와 같은 반례가 존재하기 때문이다.   </p><img src="counterexample.png" width=300 height=250 alt="반례 예시" title="반례 예시" />   <p><span class="exturl" data-url="aHR0cHM6Ly9sZGdlYW85OS50aXN0b3J5LmNvbS80MDE=">그림 출처 : LAB OF DAEGON<i class="fa fa-external-link-alt"></i></span></p><p>위의 그림은 분명 정점의 개수가 n개이고 간선의 개수가 n-1개이지만 트리가 아니다.<br>정점의 개수가 n개이고 간선의 개수가 n-1개이면서 모든 정점이 연결되어 있다는 조건이 있을 때 해당 그래프를 트리라고 말할 수 있다.<br>임의의 서로 다른 두 방 사이에 이동이 불가능한 경우가 없다는 말은 모든 방이 연결되어 있다는 말과 같다.<br>그러므로 동굴은 트리 모양으로 되어있다.   </p><h3 id="2-동굴-안에-있는-임의의-서로-다른-두-방을-연결하는-경로는-딱-한-가지만-있다"><a href="#2-동굴-안에-있는-임의의-서로-다른-두-방을-연결하는-경로는-딱-한-가지만-있다" class="headerlink" title="2. 동굴 안에 있는 임의의 서로 다른 두 방을 연결하는 경로는 딱 한 가지만 있다."></a>2. 동굴 안에 있는 임의의 서로 다른 두 방을 연결하는 경로는 딱 한 가지만 있다.</h3><p>문제 설명에 다음과 같은 조건이 있긴 하다.   </p><ul><li>임의의 서로 다른 두 방을 연결하는 최단 경로는 딱 한 가지만 있다.</li></ul><p>근데 경로가 아니라 최단 경로라고 나와 있어서 뭔가 애매하다.<br>최단 경로가 아니라 경로가 딱 한 가지만 있다는 것을 정확히 확인하고 넘어가자.<br>앞에서 동굴이 트리 모양으로 되어있다는 것을 밝혔다.<br>트리는 사이클이 존재하지 않는 그래프이기 때문에 임의의 두 노드 사이를 연결하는 경로는 유일하다(여기서 경로란 반복되는 정점과 간선이 없는 길을 말한다).<br>그러므로 동굴 안에 있는 임의의 서로 다른 두 방을 연결하는 경로는 딱 한 가지만 있다.   </p><h3 id="3-어떤-방을-방문하기-전에-반드시-동굴의-입구에서부터-해당-방까지의-경로-안에-포함된-방들을-먼저-방문해야-한다"><a href="#3-어떤-방을-방문하기-전에-반드시-동굴의-입구에서부터-해당-방까지의-경로-안에-포함된-방들을-먼저-방문해야-한다" class="headerlink" title="3. 어떤 방을 방문하기 전에 반드시 동굴의 입구에서부터 해당 방까지의 경로 안에 포함된 방들을 먼저 방문해야 한다."></a>3. 어떤 방을 방문하기 전에 반드시 동굴의 입구에서부터 해당 방까지의 경로 안에 포함된 방들을 먼저 방문해야 한다.</h3><p>동굴의 입구에서부터 어떤 방까지의 경로 안에 포함된 방들을 먼저 방문하지 않고서는 해당 방을 방문할 수 없다.<br>왜 그런 걸까?<br>결론부터 말하자면, <u><strong>동굴에는 사이클이 발생할 수 없기 때문이다</strong></u>.<br>아래의 그림과 같은 동굴이 존재한다고 가정해보자.   </p><img src="cave.png" width=350 height=350 alt="동굴 사진" title="동굴 사진" /><p>5번 방을 방문하기 위해서는 반드시 0번 방과 7번 방을 먼저 방문해야 한다.<br>왜냐하면 0번 방과 7번 방은 동굴에서부터 5번 방까지의 경로 안에 포함된 방들이기 때문이다.<br>하지만 이와 모순되게, 0번 방과 7번 방을 먼저 방문하지 않고도 5번 방을 방문할 수 있는 방법이 존재한다고 가정해보자.<br>예를 들어 아래의 그림처럼 8번 방에서부터 8번 방과 연결된 다른 방들을 통해서 5번 방으로 갈 수 있는 경로가 존재한다고 가정해보자.   </p><img src="cave2.jpg" width=350 height=350 alt="사이클이 발생한 동굴 사진" title="사이클이 발생한 동굴 사진" /><p>그러면 동굴에는 다음과 같이 0번 방에서 시작해서 0번 방으로 끝나는 사이클이 발생한다.   </p><p><code>0번</code> → 1번 → 8번 → x번 → … → y번 → 5번 → 7번 → <code>0번</code></p><p>동굴은 트리 모양으로 되어 있기 때문에 동굴에는 사이클이 발생할 수 없다.<br>그러므로 0번 방과 7번 방을 먼저 방문하지 않고도 5번 방을 방문할 수 있는 방법은 존재할 수 없다.<br>그러므로 어떤 방을 방문하기 전에 반드시 동굴의 입구에서부터 해당 방까지의 경로 안에 포함된 방들을 먼저 방문해야 한다.    </p><h2 id="문제-해결-방법"><a href="#문제-해결-방법" class="headerlink" title="문제 해결 방법"></a>문제 해결 방법</h2><p>이 문제의 해결 방법은 카카오 기술 블로그에 자세히 나와 있다.   </p><p><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLmtha2FvLmNvbS8yMDIwLzA3LzAxLzIwMjAtaW50ZXJuc2hpcC10ZXN0Lw==">2020 카카오 인턴쉽 for Tech developers 문제 해설<i class="fa fa-external-link-alt"></i></span></p><p>문제 해설에는 안 나와 있지만, 그래프의 사이클 존재 여부를 확인하기 전에 먼저 처리해주면 좋은 예외 케이스가 있다.<br>그건 바로 0번 방을 방문하기 전에 반드시 어떤 방을 먼저 방문해야 하는 경우이다.<br>동굴에 들어갈 수 있는 유일한 입구가 0번 방과 연결되어 있기 때문에 다른 모든 방을 방문하기 위해서는 반드시 0번 방을 먼저 방문해야 한다.<br>0번 방을 방문하기 전에 반드시 어떤 방을 먼저 방문해야 된다면 당연히 문제의 규칙에 맞게 모든 방을 탐험할 수 없을 것이다.<br>그러므로 이 경우에는 그래프의 사이클이 존재하는지 확인할 필요 없이 false를 리턴해주면 된다.      </p><h2 id="정답-코드"><a href="#정답-코드" class="headerlink" title="정답 코드"></a>정답 코드</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> answer = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;before, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;discover, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;finish, <span class="keyword">int</span> here)</span></span>&#123;</span><br><span class="line">    discover[here] = counter++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> there: before[here])&#123;</span><br><span class="line">        <span class="keyword">if</span> (discover[there] == <span class="number">-1</span>)&#123;</span><br><span class="line">            dfs(before, discover, finish, there);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (discover[there] &gt; discover[here])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (discover[there] &lt; discover[here])&#123;</span><br><span class="line">            <span class="keyword">if</span> (!finish[there])&#123;</span><br><span class="line">                answer = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    finish[here] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; order)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; cave(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a = path[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> b = path[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        cave[a].push_back(b);</span><br><span class="line">        cave[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; before(n);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    visited[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    q.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> here = q.front(); q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> there: cave[here])&#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[there]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            before[there].push_back(here);</span><br><span class="line"></span><br><span class="line">            visited[there] = <span class="literal">true</span>;</span><br><span class="line">            q.push(there);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; order.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a = order[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> b = order[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        before[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (before[<span class="number">0</span>].size() != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">discover</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">finish</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!answer) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (finish[i]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        dfs(before, discover, finish, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="정답-코드-해설"><a href="#정답-코드-해설" class="headerlink" title="정답 코드 해설"></a>정답 코드 해설</h2><p>34~42 - path 배열에 들어 있는 통로의 위치 정보를 통해서 동굴 그래프를 초기화해준다. 그래프의 간선 개수가 정점 개수의 제곱보다 훨씬 작기 때문에 동굴 그래프는 연결 리스트 표현 방식으로 표현한다.<br>44~62 - BFS로 그래프 탐색을 진행하며 어떤 방을 방문하기 전에 반드시 먼저 방문해야 하는 방을 표시한 before 그래프를 초기화해준다.<br>64~69 - order 배열에 들어 있는 반드시 지켜야 하는 방문 순서들을 before 그래프에 추가한다.<br>71 - 0번 방을 방문하기 전에 반드시 어떤 방을 먼저 방문해야 하는 경우를 예외 처리해준다.<br>73~81 - DFS로 before 그래프에 사이클이 존재하는지 확인한다.<br>84 - before 그래프에 사이클이 존재하는지 그 유무를 정답으로 반환한다.   </p>]]></content:encoded>
      
      
      <category domain="https://kihyunkimlee.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4/">알고리즘 문제 풀이</category>
      
      
      
      <comments>https://kihyunkimlee.github.io/2021/04/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%8F%99%EA%B5%B4-%ED%83%90%ED%97%98/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BOJ 16987] 계란으로 계란치기</title>
      <link>https://kihyunkimlee.github.io/2021/04/06/BOJ-16987-%EA%B3%84%EB%9E%80%EC%9C%BC%EB%A1%9C-%EA%B3%84%EB%9E%80%EC%B9%98%EA%B8%B0/</link>
      <guid>https://kihyunkimlee.github.io/2021/04/06/BOJ-16987-%EA%B3%84%EB%9E%80%EC%9C%BC%EB%A1%9C-%EA%B3%84%EB%9E%80%EC%B9%98%EA%B8%B0/</guid>
      <pubDate>Tue, 06 Apr 2021 09:58:25 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;문제-설명&quot;&gt;&lt;a href=&quot;#문제-설명&quot; class=&quot;headerlink&quot; title=&quot;문제 설명&quot;&gt;&lt;/a&gt;문제 설명&lt;/h2&gt;&lt;p&gt;계란의 개수 N과 N개의 계란의 내구도와 무게 정보가 주어진다.&lt;br&gt;문제에 주어진 과정대로 계란을 쳤을</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><p>계란의 개수 N과 N개의 계란의 내구도와 무게 정보가 주어진다.<br>문제에 주어진 과정대로 계란을 쳤을 때 깰 수 있는 계란의 최대 개수를 구하는 문제이다. 문제에 주어진 계란을 치는 과정은 다음과 같다.   </p><ol><li>N개의 계란이 일렬로 놓여있다.</li><li>가장 왼쪽에 있는 계란을 손에 든다.</li><li>손에 들고 있는 계란으로 깨지지 않은 다른 계란 중에서 하나를 친다.<ol><li>계란으로 계란을 치면 각 계란의 내구도는 상대 계란의 무게 만큼 감소하게 된다.</li><li>계란의 내구도가 0이하가 되면 계란은 깨진다.</li></ol></li><li>단, 손에 든 계란이 깨졌거나 깨지지 않은 다른 계란이 없으면 치지 않고 넘어간다.</li><li>이후 손에 든 계란을 제자리에 내려놓는다.</li><li>내려놓은 계란의 한 칸 오른쪽에 있는 계란을 손에 들고 3부터 다시 시작한다. 단, 제자리에 내려놓은 계란이 가장 오른쪽에 위치한 계란일 경우 계란 치는 과정을 종료한다.</li></ol><p>문제에 최적 부분 구조 성질이 성립하지 않기 때문에 그리디 알고리즘과 동적 계획법 알고리즘으로는 문제를 해결할 수 없다.<br>최적 부분 구조 성질이란 지금까지 어떤 경로로 이 부분 문제에 도달했건 남은 부분 문제는 항상 최적으로 풀어도 상관이 없는 성질이다.<br>앞에 있는 계란으로 어떤 계란을 쳤는지에 따라서 뒤에 있는 계란으로 어떤 계란을 칠 수 있는지가 결정되기 때문에 이 문제에는 최적 부분 구조 성질이 성립하지 않는다.<br>그렇다면 적용할 수 있는 알고리즘은 완전 탐색 알고리즘 밖에 없다.<br>완전 탐색 알고리즘으로 제한 시간 내에 문제를 해결할 수 있는지 알아보기 위해, 계란을 칠 수 있는 가능한 방법의 최대 개수를 계산해보자.   </p><h2 id="가능한-방법의-최대-개수"><a href="#가능한-방법의-최대-개수" class="headerlink" title="가능한 방법의 최대 개수"></a>가능한 방법의 최대 개수</h2><p>N개의 계란이 일렬로 놓여 있을 때, 가장 왼쪽에 있는 계란을 1번 계란이라 하고, 1번 계란의 한 칸 오른쪽에 있는 계란을 2번 계란, 그리고 가장 오른쪽에 있는 계란을 N번 계란이라고 하자.<br>가장 왼쪽에 있는 1번 계란을 손에 들었을 때, 나머지 N-1개의 계란은 모두 깨지지 않은 상태일 것이다.<br>왜냐하면 아직 한번도 계란으로 계란을 친적이 없기 때문이다.<br>문제에 조건에 따라 1번 계란으로 N-1개의 계란 중에 아무거나 하나를 칠 수 있다.<br>그러므로 1번 계란으로 칠 수 있는 방법의 개수는 N-1개이다.<br>1번 계란을 제자리에 놓고 2번 계란을 손에 들었을 때, 남아있을 수 있는 깨져있지 않은 계란의 최대 개수는 N-1개이다.<br>1번 계란으로 어떤 x번 계란을 쳤는데 1번 계란과 x번 계란 모두 깨지지 않은 경우에 깨져있지 않은 계란의 개수가 N-1개이기 때문이다.<br>그러므로 2번 계란으로 칠 수 있는 방법의 최대 개수는 N-1개이다.<br>3번 계란부터 N번 계란까지 각각의 계란으로 칠 수 있는 방법의 최대 개수를 구해보면 2번 계란과 같이 N-1개라는 것을 알 수 있다.<br>그러므로 가능한 방법의 최대 개수는 N-1을 N번 곱한 (N-1)^N이 된다.<br>문제에서 계란의 개수 N은 8보다 작거나 같다고 했기 때문에 가능한 방법의 최대 개수는 7^8이다.<br>가능한 모든 경우의 수가 5백만가지 정도 밖에 안되기 때문에 완전 탐색 알고리즘으로 제한 시간 내에 충분히 문제를 해결할 수 있다.   </p><h2 id="정답-코드"><a href="#정답-코드" class="headerlink" title="정답 코드"></a>정답 코드</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Egg</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> s, w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="built_in">vector</span>&lt;Egg&gt; &amp;a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = (<span class="keyword">int</span>)a.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i].s &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            cnt += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crash</span><span class="params">(<span class="built_in">vector</span>&lt;Egg&gt; &amp;a, <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    a[to].s -= a[from].w;</span><br><span class="line">    a[from].s -= a[to].w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unCrash</span><span class="params">(<span class="built_in">vector</span>&lt;Egg&gt; &amp;a, <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    a[to].s += a[from].w;</span><br><span class="line">    a[from].s += a[to].w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">go</span><span class="params">(<span class="built_in">vector</span>&lt;Egg&gt; &amp;a, <span class="keyword">int</span> from)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = (<span class="keyword">int</span>)a.size();</span><br><span class="line">    <span class="keyword">if</span> (from == n) <span class="keyword">return</span> count(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a[from].s &lt;= <span class="number">0</span>) <span class="keyword">return</span> go(a, from+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> to = <span class="number">0</span>; to &lt; n; to++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (to == from) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[to].s &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        crash(a, from, to);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = go(a, from+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; temp)&#123;</span><br><span class="line">            ans = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unCrash(a, from, to);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">return</span> go(a, from+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Egg&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i].s &gt;&gt; a[i].w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; go(a, <span class="number">0</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="정답-코드-해설"><a href="#정답-코드-해설" class="headerlink" title="정답 코드 해설"></a>정답 코드 해설</h2><p>계란을 칠 수 있는 가능한 모든 경우의 수를 만드는 과정을 각 계란으로 어떤 계란을 칠 지 결정하는 문제로 나누어서 문제를 해결하였다.   </p><p>33 - from은 현재 손에 들고 있는 계란의 인덱스 번호이다. 인덱스 번호의 범위는 0부터 N-1이다.<br>35 - from이 n과 같으면 가장 왼쪽에 있는 계란부터 가장 오른쪽에 있는 계란까지 각 계란으로 어떤 계란을 칠지 결정한 상태이다. count 함수를 호출해 깨진 계란의 개수를 세어서 그 값을 반환한다.<br>37 - 만약 현재 손에 들고 있는 계란의 내구도가 0 이하이면, 손에 들고 있는 계란은 앞에 있는 계란들에 의해서 깨져버린 상태이다. 문제에 주어진 조건에 따라 현재 손에 들고 있는 계란으로 다른 계란을 치지 않고 다음 계란으로 넘어간다.<br>41 - from 번째 계란이 깨진 상태가 아니라면, from 번째 계란으로 어떤 계란을 칠지 결정한다. 반복문을 이용해서 0부터 N-1 번째 계란을 치는 경우의 수를 만든다.<br>42~43 - 현재 손에 들고 있는 계란의 인덱스 번호와 치려는 계란의 인덱스 번호가 같으면 다음 인덱스 번째 계란으로 넘어간다. 또는 치려는 계란이 앞에 있는 계란들에 의해서 이미 깨져버린 상태라면 마찬가지로 다음 인덱스 번째 계란으로 넘어간다.<br>45&amp;57 - 현재 손에 들고 있는 계란으로 계란을 칠 수 있는 경우의 수가 하나라도 존재한다면, flag 값은 true가 된다. 만약 flag 값이 false 라면, 손에 들고 있는 계란을 제외한 나머지 계란이 모두 깨져있는 상태인 것이다. 문제에 주어진 조건에 따라 깨지지 않은 계란이 없으면 현재 손에 들고 있는 계란으로 다른 계란을 치지 않고 다음 계란으로 넘어간다.<br>49~52&amp;58 - from 번째 계란으로 칠 수 있는 모든 경우의 수 중에서 깰 수 있는 계란의 최대 개수를 구해서 정답으로 반환한다.</p>]]></content:encoded>
      
      
      <category domain="https://kihyunkimlee.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4/">알고리즘 문제 풀이</category>
      
      
      
      <comments>https://kihyunkimlee.github.io/2021/04/06/BOJ-16987-%EA%B3%84%EB%9E%80%EC%9C%BC%EB%A1%9C-%EA%B3%84%EB%9E%80%EC%B9%98%EA%B8%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BOJ 11719] 그대로 출력하기2</title>
      <link>https://kihyunkimlee.github.io/2021/03/27/BOJ-11719-%EA%B7%B8%EB%8C%80%EB%A1%9C-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B02/</link>
      <guid>https://kihyunkimlee.github.io/2021/03/27/BOJ-11719-%EA%B7%B8%EB%8C%80%EB%A1%9C-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B02/</guid>
      <pubDate>Sat, 27 Mar 2021 02:05:12 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;입력을 받은 대로 출력하는 문제이다.&lt;br&gt;입력은 최대 100줄로 이루어져 있고, 알파벳 소문자, 대문자, 공백, 숫자로만 이루어져 있다.&lt;br&gt;각 줄은 100글자를 넘지 않으며, 빈 줄이 주어질 수도 있고, 각 줄의 앞 뒤에 공백이 있을 수도 </description>
        
      
      
      
      <content:encoded><![CDATA[<p>입력을 받은 대로 출력하는 문제이다.<br>입력은 최대 100줄로 이루어져 있고, 알파벳 소문자, 대문자, 공백, 숫자로만 이루어져 있다.<br>각 줄은 100글자를 넘지 않으며, 빈 줄이 주어질 수도 있고, 각 줄의 앞 뒤에 공백이 있을 수도 있다.   </p><p><code>cin &gt;&gt; s;</code> 와 같은 방법으로는 공백이 포함된 한 줄의 문자열을 입력받을 수 없다.<br><code>cin &gt;&gt; s;</code> 은 화이트 스페이스(공백, 탭, 줄 바꿈 문자 등)를 만나기 전까지만 문자열을 입력받기 때문이다.   </p><p>C++에서는 <code>getline</code> 함수를 사용하여 문제를 해결할 수 있다.<br><code>string</code> 라이브러리 안에 들어있는 <code>getline</code> 함수는 줄 바꿈 문자나 EOF를 만날 때까지 문자열을 입력받는다.<br>그리고 두 번째 인자로 전달된 string 객체에 입력받은 문자열을 저장한다.<br>(세 번째 인자로 경계 문자를 전달하여 경계 문자 이전까지만 문자열을 입력받을 수 있다. 이때 경계 문자는 입력에 포함되지 않고 버려진다.)   </p><p>정답 코드   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span>(getline(<span class="built_in">cin</span>, s))&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://kihyunkimlee.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4/">알고리즘 문제 풀이</category>
      
      
      
      <comments>https://kihyunkimlee.github.io/2021/03/27/BOJ-11719-%EA%B7%B8%EB%8C%80%EB%A1%9C-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B02/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BOJ 10951] A+B - 4</title>
      <link>https://kihyunkimlee.github.io/2021/03/27/BOJ-10951-A+B-4/</link>
      <guid>https://kihyunkimlee.github.io/2021/03/27/BOJ-10951-A+B-4/</guid>
      <pubDate>Sat, 27 Mar 2021 01:01:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;두 정수 A와 B를 입력받은 다음, A+B를 출력하는 문제이다.&lt;br&gt;단, 테스트 케이스의 개수를 미리 알 수 없기 때문에 EOF에 도달할 때까지 입력을 받아야 한다.   &lt;/p&gt;
&lt;p&gt;C++에서는 아래와 같은 방법으로 EOF에 도달할 때까지 입</description>
        
      
      
      
      <content:encoded><![CDATA[<p>두 정수 A와 B를 입력받은 다음, A+B를 출력하는 문제이다.<br>단, 테스트 케이스의 개수를 미리 알 수 없기 때문에 EOF에 도달할 때까지 입력을 받아야 한다.   </p><p>C++에서는 아래와 같은 방법으로 EOF에 도달할 때까지 입력을 받을 수 있다.   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b)</span><br></pre></td></tr></table></figure><p><code>cin</code>은 EOF에 도달하거나 에러가 발생하면 false를 반한다.<br>(정확히 말하면 <code>cin</code>객체가 반환되는데, 이 객체는 if 문이나 while 문 안에 있으면 형변환 연산자에 의해서 자동으로 불리언 값으로 바뀐다고 한다. 정상적으로 데이터를 읽어오면 true가 되고 EOF에 도달하거나 에러가 발생하면 false가 된다.)   </p><p>정답 코드   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a+b &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://kihyunkimlee.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4/">알고리즘 문제 풀이</category>
      
      
      
      <comments>https://kihyunkimlee.github.io/2021/03/27/BOJ-10951-A+B-4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>C++ 간단하게 정수 자릿수 바꾸기</title>
      <link>https://kihyunkimlee.github.io/2021/03/03/c++-easy-way-to-change-the-digits-of-integers/</link>
      <guid>https://kihyunkimlee.github.io/2021/03/03/c++-easy-way-to-change-the-digits-of-integers/</guid>
      <pubDate>Wed, 03 Mar 2021 12:58:01 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;BOJ &lt;code&gt;알고리즘 온라인 강의&lt;/code&gt;를 수강하면서 간단하게 정수의 자릿수를 바꾸는 방법을 알게 되었다.&lt;br&gt;정수를 문자열로 바꾼 다음에 인덱스를 통해 특정 자릿수를 원하는 숫자로 바꾸고, 다시 문자열을 정수로 바꿔주는 것이다.&lt;b</description>
        
      
      
      
      <content:encoded><![CDATA[<p>BOJ <code>알고리즘 온라인 강의</code>를 수강하면서 간단하게 정수의 자릿수를 바꾸는 방법을 알게 되었다.<br>정수를 문자열로 바꾼 다음에 인덱스를 통해 특정 자릿수를 원하는 숫자로 바꾸고, 다시 문자열을 정수로 바꿔주는 것이다.<br>산술 연산을 통해 정수 자릿수를 바꾸는 방법보다 오버헤드가 발생하지만, 구현하기 쉽고 간단해서 실수할 걱정이 없는게 좋은거 같다.   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> index, <span class="keyword">int</span> digit)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = to_string(num);</span><br><span class="line">    s[index] = digit + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> stoi(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">9999</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; change(num, <span class="number">0</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1999</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; change(num, <span class="number">1</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 9199</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; change(num, <span class="number">2</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 9919</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; change(num, <span class="number">3</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 9991</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://kihyunkimlee.github.io/categories/C/">C++</category>
      
      
      
      <comments>https://kihyunkimlee.github.io/2021/03/03/c++-easy-way-to-change-the-digits-of-integers/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
