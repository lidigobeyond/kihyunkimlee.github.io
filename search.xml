<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[BOJ 10951] A+B - 4</title>
    <url>/2021/03/27/BOJ-10951-A+B-4/</url>
    <content><![CDATA[<p>두 정수 A와 B를 입력받은 다음, A+B를 출력하는 문제이다.<br>단, 테스트 케이스의 개수를 미리 알 수 없기 때문에 EOF에 도달할 때까지 입력을 받아야 한다.   </p>
<p>C++에서는 아래와 같은 방법으로 EOF에 도달할 때까지 입력을 받을 수 있다.   </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b)</span><br></pre></td></tr></table></figure>
<p><code>cin</code>은 EOF에 도달하거나 에러가 발생하면 false를 반한다.<br>(정확히 말하면 <code>cin</code>객체가 반환되는데, 이 객체는 if 문이나 while 문 안에 있으면 형변환 연산자에 의해서 자동으로 불리언 값으로 바뀐다고 한다. 정상적으로 데이터를 읽어오면 true가 되고 EOF에 도달하거나 에러가 발생하면 false가 된다.)   </p>
<p>정답 코드   </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a+b &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>알고리즘 문제 풀이</category>
      </categories>
      <tags>
        <tag>알고리즘 문제</tag>
        <tag>BOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>[BOJ 11719] 그대로 출력하기2</title>
    <url>/2021/03/27/BOJ-11719-%EA%B7%B8%EB%8C%80%EB%A1%9C-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B02/</url>
    <content><![CDATA[<p>입력을 받은 대로 출력하는 문제이다.<br>입력은 최대 100줄로 이루어져 있고, 알파벳 소문자, 대문자, 공백, 숫자로만 이루어져 있다.<br>각 줄은 100글자를 넘지 않으며, 빈 줄이 주어질 수도 있고, 각 줄의 앞 뒤에 공백이 있을 수도 있다.   </p>
<p><code>cin &gt;&gt; s;</code> 와 같은 방법으로는 공백이 포함된 한 줄의 문자열을 입력받을 수 없다.<br><code>cin &gt;&gt; s;</code> 은 화이트 스페이스(공백, 탭, 줄 바꿈 문자 등)를 만나기 전까지만 문자열을 입력받기 때문이다.   </p>
<p>C++에서는 <code>getline</code> 함수를 사용하여 문제를 해결할 수 있다.<br><code>string</code> 라이브러리 안에 들어있는 <code>getline</code> 함수는 줄 바꿈 문자나 EOF를 만날 때까지 문자열을 입력받는다.<br>그리고 두 번째 인자로 전달된 string 객체에 입력받은 문자열을 저장한다.<br>(세 번째 인자로 경계 문자를 전달하여 경계 문자 이전까지만 문자열을 입력받을 수 있다. 이때 경계 문자는 입력에 포함되지 않고 버려진다.)   </p>
<p>정답 코드   </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span>(getline(<span class="built_in">cin</span>, s))&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>알고리즘 문제 풀이</category>
      </categories>
      <tags>
        <tag>알고리즘 문제</tag>
        <tag>BOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>[BOJ 16987] 계란으로 계란치기</title>
    <url>/2021/04/06/BOJ-16987-%EA%B3%84%EB%9E%80%EC%9C%BC%EB%A1%9C-%EA%B3%84%EB%9E%80%EC%B9%98%EA%B8%B0/</url>
    <content><![CDATA[<h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><p>계란의 개수 N과 N개의 계란의 내구도와 무게 정보가 주어진다.<br>문제에 주어진 과정대로 계란을 쳤을 때 깰 수 있는 계란의 최대 개수를 구하는 문제이다. 문제에 주어진 계란을 치는 과정은 다음과 같다.   </p>
<ol>
<li>N개의 계란이 일렬로 놓여있다.</li>
<li>가장 왼쪽에 있는 계란을 손에 든다.</li>
<li>손에 들고 있는 계란으로 깨지지 않은 다른 계란 중에서 하나를 친다.<ol>
<li>계란으로 계란을 치면 각 계란의 내구도는 상대 계란의 무게 만큼 감소하게 된다.</li>
<li>계란의 내구도가 0이하가 되면 계란은 깨진다.</li>
</ol>
</li>
<li>단, 손에 든 계란이 깨졌거나 깨지지 않은 다른 계란이 없으면 치지 않고 넘어간다.</li>
<li>이후 손에 든 계란을 제자리에 내려놓는다.</li>
<li>내려놓은 계란의 한 칸 오른쪽에 있는 계란을 손에 들고 3부터 다시 시작한다. 단, 제자리에 내려놓은 계란이 가장 오른쪽에 위치한 계란일 경우 계란 치는 과정을 종료한다.</li>
</ol>
<p>문제에 최적 부분 구조 성질이 성립하지 않기 때문에 그리디 알고리즘과 동적 계획법 알고리즘으로는 문제를 해결할 수 없다.<br>최적 부분 구조 성질이란 지금까지 어떤 경로로 이 부분 문제에 도달했건 남은 부분 문제는 항상 최적으로 풀어도 상관이 없는 성질이다.<br>앞에 있는 계란으로 어떤 계란을 쳤는지에 따라서 뒤에 있는 계란으로 어떤 계란을 칠 수 있는지가 결정되기 때문에 이 문제에는 최적 부분 구조 성질이 성립하지 않는다.<br>그렇다면 적용할 수 있는 알고리즘은 완전 탐색 알고리즘 밖에 없다.<br>완전 탐색 알고리즘으로 제한 시간 내에 문제를 해결할 수 있는지 알아보기 위해, 계란을 칠 수 있는 가능한 방법의 최대 개수를 계산해보자.   </p>
<br>

<h2 id="가능한-방법의-최대-개수"><a href="#가능한-방법의-최대-개수" class="headerlink" title="가능한 방법의 최대 개수"></a>가능한 방법의 최대 개수</h2><p>N개의 계란이 일렬로 놓여 있을 때, 가장 왼쪽에 있는 계란을 1번 계란이라 하고, 1번 계란의 한 칸 오른쪽에 있는 계란을 2번 계란, 그리고 가장 오른쪽에 있는 계란을 N번 계란이라고 하자.<br>가장 왼쪽에 있는 1번 계란을 손에 들었을 때, 나머지 N-1개의 계란은 모두 깨지지 않은 상태일 것이다.<br>왜냐하면 아직 한번도 계란으로 계란을 친적이 없기 때문이다.<br>문제에 조건에 따라 1번 계란으로 N-1개의 계란 중에 아무거나 하나를 칠 수 있다.<br>그러므로 1번 계란으로 칠 수 있는 방법의 개수는 N-1개이다.<br>1번 계란을 제자리에 놓고 2번 계란을 손에 들었을 때, 남아있을 수 있는 깨져있지 않은 계란의 최대 개수는 N-1개이다.<br>1번 계란으로 어떤 x번 계란을 쳤는데 1번 계란과 x번 계란 모두 깨지지 않은 경우에 깨져있지 않은 계란의 개수가 N-1개이기 때문이다.<br>그러므로 2번 계란으로 칠 수 있는 방법의 최대 개수는 N-1개이다.<br>3번 계란부터 N번 계란까지 각각의 계란으로 칠 수 있는 방법의 최대 개수를 구해보면 2번 계란과 같이 N-1개라는 것을 알 수 있다.<br>그러므로 가능한 방법의 최대 개수는 N-1을 N번 곱한 (N-1)^N이 된다.<br>문제에서 계란의 개수 N은 8보다 작거나 같다고 했기 때문에 가능한 방법의 최대 개수는 7^8이다.<br>가능한 모든 경우의 수가 5백만가지 정도 밖에 안되기 때문에 완전 탐색 알고리즘으로 제한 시간 내에 충분히 문제를 해결할 수 있다.   </p>
<br>

<h2 id="정답-코드"><a href="#정답-코드" class="headerlink" title="정답 코드"></a>정답 코드</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Egg</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> s, w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="built_in">vector</span>&lt;Egg&gt; &amp;a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = (<span class="keyword">int</span>)a.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i].s &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            cnt += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crash</span><span class="params">(<span class="built_in">vector</span>&lt;Egg&gt; &amp;a, <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    a[to].s -= a[from].w;</span><br><span class="line">    a[from].s -= a[to].w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unCrash</span><span class="params">(<span class="built_in">vector</span>&lt;Egg&gt; &amp;a, <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    a[to].s += a[from].w;</span><br><span class="line">    a[from].s += a[to].w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">go</span><span class="params">(<span class="built_in">vector</span>&lt;Egg&gt; &amp;a, <span class="keyword">int</span> from)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = (<span class="keyword">int</span>)a.size();</span><br><span class="line">    <span class="keyword">if</span> (from == n) <span class="keyword">return</span> count(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a[from].s &lt;= <span class="number">0</span>) <span class="keyword">return</span> go(a, from+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> to = <span class="number">0</span>; to &lt; n; to++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (to == from) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[to].s &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        crash(a, from, to);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = go(a, from+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; temp)&#123;</span><br><span class="line">            ans = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unCrash(a, from, to);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">return</span> go(a, from+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Egg&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i].s &gt;&gt; a[i].w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; go(a, <span class="number">0</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<h2 id="정답-코드-해설"><a href="#정답-코드-해설" class="headerlink" title="정답 코드 해설"></a>정답 코드 해설</h2><p>계란을 칠 수 있는 가능한 모든 경우의 수를 만드는 과정을 각 계란으로 어떤 계란을 칠 지 결정하는 문제로 나누어서 문제를 해결하였다.   </p>
<p>33 - from은 현재 손에 들고 있는 계란의 인덱스 번호이다. 인덱스 번호의 범위는 0부터 N-1이다.<br>35 - from이 n과 같으면 가장 왼쪽에 있는 계란부터 가장 오른쪽에 있는 계란까지 각 계란으로 어떤 계란을 칠지 결정한 상태이다. count 함수를 호출해 깨진 계란의 개수를 세어서 그 값을 반환한다.<br>37 - 만약 현재 손에 들고 있는 계란의 내구도가 0 이하이면, 손에 들고 있는 계란은 앞에 있는 계란들에 의해서 깨져버린 상태이다. 문제에 주어진 조건에 따라 현재 손에 들고 있는 계란으로 다른 계란을 치지 않고 다음 계란으로 넘어간다.<br>41 - from 번째 계란이 깨진 상태가 아니라면, from 번째 계란으로 어떤 계란을 칠지 결정한다. 반복문을 이용해서 0부터 N-1 번째 계란을 치는 경우의 수를 만든다.<br>42~43 - 현재 손에 들고 있는 계란의 인덱스 번호와 치려는 계란의 인덱스 번호가 같으면 다음 인덱스 번째 계란으로 넘어간다. 또는 치려는 계란이 앞에 있는 계란들에 의해서 이미 깨져버린 상태라면 마찬가지로 다음 인덱스 번째 계란으로 넘어간다.<br>45&amp;57 - 현재 손에 들고 있는 계란으로 계란을 칠 수 있는 경우의 수가 하나라도 존재한다면, flag 값은 true가 된다. 만약 flag 값이 false 라면, 손에 들고 있는 계란을 제외한 나머지 계란이 모두 깨져있는 상태인 것이다. 문제에 주어진 조건에 따라 깨지지 않은 계란이 없으면 현재 손에 들고 있는 계란으로 다른 계란을 치지 않고 다음 계란으로 넘어간다.<br>49~52&amp;58 - from 번째 계란으로 칠 수 있는 모든 경우의 수 중에서 깰 수 있는 계란의 최대 개수를 구해서 정답으로 반환한다.</p>
]]></content>
      <categories>
        <category>알고리즘 문제 풀이</category>
      </categories>
      <tags>
        <tag>알고리즘 문제</tag>
        <tag>BOJ</tag>
        <tag>완전 탐색</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 간단하게 정수 자릿수 바꾸기</title>
    <url>/2021/03/03/c++-easy-way-to-change-the-digits-of-integers/</url>
    <content><![CDATA[<p>BOJ <code>알고리즘 온라인 강의</code>를 수강하면서 간단하게 정수의 자릿수를 바꾸는 방법을 알게 되었다.<br>정수를 문자열로 바꾼 다음에 인덱스를 통해 특정 자릿수를 원하는 숫자로 바꾸고, 다시 문자열을 정수로 바꿔주는 것이다.<br>산술 연산을 통해 정수 자릿수를 바꾸는 방법보다 오버헤드가 발생하지만, 구현하기 쉽고 간단해서 실수할 걱정이 없는게 좋은거 같다.   </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> index, <span class="keyword">int</span> digit)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = to_string(num);</span><br><span class="line">    s[index] = digit + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> stoi(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">9999</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; change(num, <span class="number">0</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1999</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; change(num, <span class="number">1</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 9199</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; change(num, <span class="number">2</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 9919</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; change(num, <span class="number">3</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 9991</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>[프로그래머스] 동굴 탐험</title>
    <url>/2021/04/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%8F%99%EA%B5%B4-%ED%83%90%ED%97%98/</url>
    <content><![CDATA[<h2 id="문제를-읽고-나서-알아차려야-했던-것들-3가지"><a href="#문제를-읽고-나서-알아차려야-했던-것들-3가지" class="headerlink" title="문제를 읽고 나서 알아차려야 했던 것들 3가지"></a>문제를 읽고 나서 알아차려야 했던 것들 3가지</h2><p>문제 해결을 위해서 문제를 읽고 나서 알아차려야 했던 것들이 있다.   </p>
<h3 id="1-동굴은-트리-모양으로-되어있다"><a href="#1-동굴은-트리-모양으로-되어있다" class="headerlink" title="1. 동굴은 트리 모양으로 되어있다."></a>1. 동굴은 트리 모양으로 되어있다.</h3><p>문제에는 동굴이 트리 모양이라고 직접적으로 명시되어있지 않다.<br>하지만 문제를 읽어보면 다음과 같은 조건을 찾을 수 있다.   </p>
<ul>
<li>방의 개수가 n개일 때 방과 방 사이를 연결하는 통로의 개수는 n-1개이다(문제의 제한사항에 나와 있다).</li>
<li>임의의 서로 다른 두 방을 연결하는 최단 경로는 딱 한 가지만 있으며, 두 방 사이에 이동이 불가능한 경우는 없다.</li>
</ul>
<p>방의 개수가 n개이고 방과 방 사이를 연결하는 통로의 개수가 n-1개이므로 동굴이 트리 모양이라고 확신할 수 있을까…?<br>정답은 <u><strong>확신할 수 없다</strong></u>이다.<br>트리의 정의가 정점의 개수가 n개이고 간선의 개수가 n-1개인, 사이클이 존재하지 않는 그래프인 건 맞다.<br>하지만 정점의 개수가 n개이고 간선의 개수가 n-1개인 그래프가 항상 트리인 것은 아니다.<br>왜냐하면 아래와 같은 반례가 존재하기 때문이다.   </p>
<img src="/2021/04/24/프로그래머스-동굴-탐험/counterexample.png" width=300 height=250 alt="반례 예시" title="반례 예시" />   

<p><span class="exturl" data-url="aHR0cHM6Ly9sZGdlYW85OS50aXN0b3J5LmNvbS80MDE=">그림 출처 : LAB OF DAEGON<i class="fa fa-external-link-alt"></i></span></p>
<p>위의 그림은 분명 정점의 개수가 n개이고 간선의 개수가 n-1개이지만 트리가 아니다.<br>정점의 개수가 n개이고 간선의 개수가 n-1개이면서 모든 정점이 연결되어 있다는 조건이 있을 때 해당 그래프를 트리라고 말할 수 있다.<br>임의의 서로 다른 두 방 사이에 이동이 불가능한 경우가 없다는 말은 모든 방이 연결되어 있다는 말과 같다.<br>그러므로 동굴은 트리 모양으로 되어있다.   </p>
<h3 id="2-동굴-안에-있는-임의의-서로-다른-두-방을-연결하는-경로는-딱-한-가지만-있다"><a href="#2-동굴-안에-있는-임의의-서로-다른-두-방을-연결하는-경로는-딱-한-가지만-있다" class="headerlink" title="2. 동굴 안에 있는 임의의 서로 다른 두 방을 연결하는 경로는 딱 한 가지만 있다."></a>2. 동굴 안에 있는 임의의 서로 다른 두 방을 연결하는 경로는 딱 한 가지만 있다.</h3><p>문제 설명에 다음과 같은 조건이 있긴 하다.   </p>
<ul>
<li>임의의 서로 다른 두 방을 연결하는 최단 경로는 딱 한 가지만 있다.</li>
</ul>
<p>근데 경로가 아니라 최단 경로라고 나와 있어서 뭔가 애매하다.<br>최단 경로가 아니라 경로가 딱 한 가지만 있다는 것을 정확히 확인하고 넘어가자.<br>앞에서 동굴이 트리 모양으로 되어있다는 것을 밝혔다.<br>트리는 사이클이 존재하지 않는 그래프이기 때문에 임의의 두 노드 사이를 연결하는 경로는 유일하다(여기서 경로란 반복되는 정점과 간선이 없는 길을 말한다).<br>그러므로 동굴 안에 있는 임의의 서로 다른 두 방을 연결하는 경로는 딱 한 가지만 있다.   </p>
<h3 id="3-어떤-방을-방문하기-전에-반드시-동굴의-입구에서부터-해당-방까지의-경로-안에-포함된-방들을-먼저-방문해야-한다"><a href="#3-어떤-방을-방문하기-전에-반드시-동굴의-입구에서부터-해당-방까지의-경로-안에-포함된-방들을-먼저-방문해야-한다" class="headerlink" title="3. 어떤 방을 방문하기 전에 반드시 동굴의 입구에서부터 해당 방까지의 경로 안에 포함된 방들을 먼저 방문해야 한다."></a>3. 어떤 방을 방문하기 전에 반드시 동굴의 입구에서부터 해당 방까지의 경로 안에 포함된 방들을 먼저 방문해야 한다.</h3><p>동굴의 입구에서부터 어떤 방까지의 경로 안에 포함된 방들을 먼저 방문하지 않고서는 해당 방을 방문할 수 없다.<br>왜 그런 걸까?<br>결론부터 말하자면, <u><strong>동굴에는 사이클이 발생할 수 없기 때문이다</strong></u>.<br>아래의 그림과 같은 동굴이 존재한다고 가정해보자.   </p>
<img src="/2021/04/24/프로그래머스-동굴-탐험/cave.png" width=350 height=350 alt="동굴 사진" title="동굴 사진" />

<p>5번 방을 방문하기 위해서는 반드시 0번 방과 7번 방을 먼저 방문해야 한다.<br>왜냐하면 0번 방과 7번 방은 동굴에서부터 5번 방까지의 경로 안에 포함된 방들이기 때문이다.<br>하지만 이와 모순되게, 0번 방과 7번 방을 먼저 방문하지 않고도 5번 방을 방문할 수 있는 방법이 존재한다고 가정해보자.<br>예를 들어 아래의 그림처럼 8번 방에서부터 8번 방과 연결된 다른 방들을 통해서 5번 방으로 갈 수 있는 경로가 존재한다고 가정해보자.   </p>
<img src="/2021/04/24/프로그래머스-동굴-탐험/cave2.jpg" width=350 height=350 alt="사이클이 발생한 동굴 사진" title="사이클이 발생한 동굴 사진" />

<p>그러면 동굴에는 다음과 같이 0번 방에서 시작해서 0번 방으로 끝나는 사이클이 발생한다.   </p>
<p><code>0번</code> → 1번 → 8번 → x번 → … → y번 → 5번 → 7번 → <code>0번</code></p>
<p>동굴은 트리 모양으로 되어 있기 때문에 동굴에는 사이클이 발생할 수 없다.<br>그러므로 0번 방과 7번 방을 먼저 방문하지 않고도 5번 방을 방문할 수 있는 방법은 존재할 수 없다.<br>그러므로 어떤 방을 방문하기 전에 반드시 동굴의 입구에서부터 해당 방까지의 경로 안에 포함된 방들을 먼저 방문해야 한다.    </p>
<br>

<h2 id="문제-해결-방법"><a href="#문제-해결-방법" class="headerlink" title="문제 해결 방법"></a>문제 해결 방법</h2><p>이 문제의 해결 방법은 카카오 기술 블로그에 자세히 나와 있다.   </p>
<p><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLmtha2FvLmNvbS8yMDIwLzA3LzAxLzIwMjAtaW50ZXJuc2hpcC10ZXN0Lw==">2020 카카오 인턴쉽 for Tech developers 문제 해설<i class="fa fa-external-link-alt"></i></span></p>
<p>문제 해설에는 안 나와 있지만, 그래프의 사이클 존재 여부를 확인하기 전에 먼저 처리해주면 좋은 예외 케이스가 있다.<br>그건 바로 0번 방을 방문하기 전에 반드시 어떤 방을 먼저 방문해야 하는 케이스이다.<br>동굴에 들어갈 수 있는 유일한 입구가 0번 방과 연결되어 있기 때문에 다른 모든 방을 방문하기 위해서는 반드시 0번 방을 먼저 방문해야 한다.<br>0번 방을 방문하기 전에 반드시 어떤 방을 먼저 방문해야 된다면 당연히 문제의 규칙에 맞게 모든 방을 탐험할 수 없을 것이다.<br>그러므로 이 경우에는 그래프의 사이클이 존재하는지 확인할 필요 없이 false를 리턴해주면 된다.      </p>
<br>

<h2 id="정답-코드"><a href="#정답-코드" class="headerlink" title="정답 코드"></a>정답 코드</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> answer = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;before, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;discover, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;finish, <span class="keyword">int</span> here)</span></span>&#123;</span><br><span class="line">    discover[here] = counter++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> there: before[here])&#123;</span><br><span class="line">        <span class="keyword">if</span> (discover[there] == <span class="number">-1</span>)&#123;</span><br><span class="line">            dfs(before, discover, finish, there);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (discover[there] &gt; discover[here])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (discover[there] &lt; discover[here])&#123;</span><br><span class="line">            <span class="keyword">if</span> (!finish[there])&#123;</span><br><span class="line">                answer = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    finish[here] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; order)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; cave(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a = path[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> b = path[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        cave[a].push_back(b);</span><br><span class="line">        cave[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; before(n);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    visited[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    q.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> here = q.front(); q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> there: cave[here])&#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[there]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            before[there].push_back(here);</span><br><span class="line"></span><br><span class="line">            visited[there] = <span class="literal">true</span>;</span><br><span class="line">            q.push(there);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; order.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a = order[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> b = order[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        before[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (before[<span class="number">0</span>].size() != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">discover</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">finish</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!answer) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (finish[i]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        dfs(before, discover, finish, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<h2 id="정답-코드-해설"><a href="#정답-코드-해설" class="headerlink" title="정답 코드 해설"></a>정답 코드 해설</h2><p>34~42 - path 배열에 들어 있는 통로의 위치 정보를 통해서 동굴 그래프를 초기화해준다. 그래프의 간선 개수가 정점 개수의 제곱보다 훨씬 작기 때문에 동굴 그래프는 연결 리스트 표현 방식으로 표현했다.<br>44~62 - BFS로 그래프 탐색을 진행하며 어떤 방을 방문하기 전에 반드시 먼저 방문해야 하는 방을 표시한 before 그래프를 초기화해준다.<br>64~69 - order 배열에 들어 있는 반드시 지켜야 하는 방문 순서들을 before 그래프에 추가한다.<br>71 - 0번 방을 방문하기 전에 반드시 어떤 방을 먼저 방문해야 하는 경우를 예외 케이스로 처리해준다.<br>73~81 - DFS로 before 그래프에 사이클이 존재하는지 확인한다.<br>84 - before 그래프에 사이클이 존재하는지 여부를 문제의 정답으로 반환한다.   </p>
]]></content>
      <categories>
        <category>알고리즘 문제 풀이</category>
      </categories>
      <tags>
        <tag>프로그래머스</tag>
        <tag>알고리즘 문제</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>[프로그래머스] NULL 처리하기</title>
    <url>/2021/05/03/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-NULL-%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0/</url>
    <content><![CDATA[<h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><p>동물의 생물 종(ANIMAL_TYPE), 이름(NAME), 성별 및 중성화 여부(SEX_UPON_INTAKE)를 아이디(ANIMAL_ID) 순으로 조회하는 SQL문을 작성해야 하는 문제이다.<br>이때 이름이 없는 동물의 이름은 “No name”으로 표시해야 한다.<br>(이름이 없는 동물이란 이름 칼럼의 값이 NULL인 레코드를 의미한다)   </p>
<p>특정 칼럼의 값이 NULL일 때 다른 값으로 치환해서 출력하는 방법은 여러 가지가 있다.   </p>
<br>

<h2 id="1-IFNULL-함수를-이용한-방법"><a href="#1-IFNULL-함수를-이용한-방법" class="headerlink" title="1. IFNULL 함수를 이용한 방법"></a>1. IFNULL 함수를 이용한 방법</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">IFNULL(expression, alt_value)   </span><br></pre></td></tr></table></figure>
<p>IFNULL 함수는 첫 번째 매개 변수의 값이 NULL이면 두 번째 매개 변수의 값을 반환한다.<br>첫 번째 매개 변수의 값이 NULL이 아니면 첫 번째 매개 변수의 값을 반환한다.   </p>
<h3 id="정답-코드"><a href="#정답-코드" class="headerlink" title="정답 코드"></a>정답 코드</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ANIMAL_TYPE, IFNULL(NAME, &quot;No name&quot;) <span class="keyword">AS</span> NAME, SEX_UPON_INTAKE</span><br><span class="line"><span class="keyword">FROM</span> ANIMAL_INS</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ANIMAL_ID;</span><br></pre></td></tr></table></figure>
<br>

<h2 id="2-COALESCE-함수를-이용한-방법"><a href="#2-COALESCE-함수를-이용한-방법" class="headerlink" title="2. COALESCE 함수를 이용한 방법"></a>2. COALESCE 함수를 이용한 방법</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">COALESCE</span>(val_1, val_2, ..., val_n)</span><br></pre></td></tr></table></figure>
<p>COALESCE 함수는 임의의 개수의 매개 변수에서 NULL이 아닌 최초의 매개 변수의 값을 반환한다.   </p>
<p>예를 들어 아래와 같은 SQL문을 실행시키면,</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COALESCE</span>(<span class="keyword">NULL</span>, <span class="keyword">NULL</span>, &quot;HELLO&quot;, <span class="keyword">NULL</span>, &quot;WORLD&quot;);</span><br></pre></td></tr></table></figure>
<p>NULL이 아닌 최초의 매개 변수의 값 “HELLO”가 출력된다.   </p>
<p>반면에 모든 매개 변수의 값이 NULL이면 NULL을 반환한다.   </p>
<h3 id="정답-코드-1"><a href="#정답-코드-1" class="headerlink" title="정답 코드"></a>정답 코드</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ANIMAL_TYPE, <span class="built_in">COALESCE</span>(NAME, &quot;No name&quot;) <span class="keyword">AS</span> NAME, SEX_UPON_INTAKE</span><br><span class="line"><span class="keyword">FROM</span> ANIMAL_INS</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ANIMAL_ID;</span><br></pre></td></tr></table></figure>
<br>

<h2 id="3-CASE를-이용한-방법"><a href="#3-CASE를-이용한-방법" class="headerlink" title="3. CASE를 이용한 방법"></a>3. CASE를 이용한 방법</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CASE</span></span><br><span class="line">  <span class="keyword">WHEN</span> condition1 <span class="keyword">THEN</span> result1</span><br><span class="line">  <span class="keyword">WHEN</span> condition2 <span class="keyword">THEN</span> result2</span><br><span class="line">  <span class="keyword">ELSE</span> <span class="keyword">result</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<p>CASE 문은 프로그래밍 언어의 다중 if-else 문과 비슷하다.<br>위에서부터 차례대로 조건식이 참인지 거짓인지 판별한다.<br>조건식이 거짓인 경우 그 다음 조건식이 참인지 거짓인지 판별한다.<br>조건식이 참인 경우 더이상 조건식을 판별하지 않고 THEN에 명시된 값을 반환하고 종료한다.<br>참인 조건식이 하나도 없으면 ELSE에 명시된 값을 반환하고 종료한다.   </p>
<p>한 가지 주의해야 할 점은, ELSE를 명시하지 않았을 경우 참인 조건식이 하나도 없으면 NULL을 반환한다는 것이다.<br>그러므로 CASE문을 사용할 때는 반드시 ELSE를 명시해주는 것이 좋다.   </p>
<h3 id="정답-코드-2"><a href="#정답-코드-2" class="headerlink" title="정답 코드"></a>정답 코드</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ANIMAL_TYPE,</span><br><span class="line">  <span class="keyword">CASE</span></span><br><span class="line">    <span class="keyword">WHEN</span> NAME <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span> NAME</span><br><span class="line">    <span class="keyword">ELSE</span> &quot;No name&quot;</span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">AS</span> NAME</span><br><span class="line">  , SEX_UPON_INTAKE</span><br><span class="line"><span class="keyword">FROM</span> ANIMAL_INS</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ANIMAL_ID;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SQL 문제 풀이</category>
      </categories>
      <tags>
        <tag>프로그래머스</tag>
        <tag>SQL 문제</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>프로그래머스 2021 여름방학 스타트업 인턴 프로그램 코딩 테스트 후기</title>
    <url>/2021/05/11/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-2021-%EC%97%AC%EB%A6%84%EB%B0%A9%ED%95%99-%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85-%EC%9D%B8%ED%84%B4-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%9B%84%EA%B8%B0/</url>
    <content><![CDATA[<img src="/2021/05/11/프로그래머스-2021-여름방학-스타트업-인턴-프로그램-코딩-테스트-후기/2021-summer_coding__prgm__img-banner.jpg" width=700 height=350 alt="프로그래머스 2021 여름방학 스타트업 인턴 프로그램 배너 사진" title="프로그래머스 2021 여름방학 스타트업 인턴 프로그램 배너 사진" />

<p>이번에 아주 오래전부터 참여하고 싶었던 프로그래머스 스타트업 인턴 프로그램에 지원하게 되었다.<br>프로그래머스 스타트업 인턴 프로그램을 준비하기 위해서 4월부터 정말 바쁘게 보냈다.<br>개발하고 있었던 토이 프로젝트도 부지런히 마무리 지었고, 코딩 테스트 준비를 위해서 프로그래머스 사이트에서 알고리즘 문제도 열심히 풀었다.</p>
<p>5월 9일, 어버이날에 코딩 테스트 시험을 치렀다.<br>작년과 똑같이 알고리즘 3문제와 SQL 1문제가 출제되었다.<br>간단하게 풀었던 시험 문제를 블로그에 리뷰해보려고 한다.</p>
<br>

<h2 id="시험-문제-리뷰"><a href="#시험-문제-리뷰" class="headerlink" title="시험 문제 리뷰"></a>시험 문제 리뷰</h2><h3 id="1번-문제-100-100"><a href="#1번-문제-100-100" class="headerlink" title="1번 문제 (100/100)"></a>1번 문제 (100/100)</h3><ul>
<li>비교적 쉬운 문자열 처리 문제였다.</li>
<li>하나의 문자열로 주어지는 데이터를 적절히 처리하여 필요한 데이터만 추출한 다음, 그중에서 조건에 맞는 데이터만 선별한 뒤, 문제에 조건에 맞게 데이터를 정렬해서 정답을 만들었다.</li>
<li>첫 문제라 너무 긴장이 돼서 코드를 간결하게 작성하지 못했는데, 그게 좀 아쉽다.</li>
</ul>
<h3 id="2번-문제-100-100"><a href="#2번-문제-100-100" class="headerlink" title="2번 문제 (100/100)"></a>2번 문제 (100/100)</h3><ul>
<li>그리디 알고리즘 문제였다.</li>
<li>우선순위 큐를 사용해서 그때 그때마다 우선순위가 가장 높은 값을 뽑아내서 정답을 만들어나갔다.</li>
<li>문제를 꼼꼼히 읽지 않아서 두 번째 문제를 풀 때 실수를 많이 했다.</li>
<li>앞으로 문제를 꼼꼼히 읽는 습관을 들여야겠다.</li>
</ul>
<h3 id="3번-문제-100-100"><a href="#3번-문제-100-100" class="headerlink" title="3번 문제 (100/100)"></a>3번 문제 (100/100)</h3><ul>
<li>그래프 탐색 문제였다.</li>
<li>3번 문제를 풀 수 있는 시간이 채 20분도 남지 않았어서, 진짜 알고리즘 구상과 동시에 바로 코드로 옮겨 적은 거 같다.</li>
<li>다행히도 내가 구상했던 문제 해결 방법이 예외 케이스 없이 모두 맞아서 100점을 받았다.</li>
<li>문제 해결 방법은 다음과 같다.</li>
<li>공격 시작점이 (y, x)라면, 시작점에서 인접한 4개의 칸 (y-1, x-1), (y-1, x), (y, x-1), (y, x)를 시작 지점으로 해서 BFS 알고리즘으로 나머지 인접한 칸을 탐색해나갔다.<ul>
<li>시작 지점에서부터 어떤 지점까지의 최단 경로 길이가 (r/2)-1 미만인 경우<ul>
<li>해당 지점은 100%의 데미지를 받는 지점이다.</li>
<li>체력이 p보다 작은 칸의 개수를 정답으로 세준다.</li>
</ul>
</li>
<li>시작 지점에서부터 어떤 지점까지의 최단 경로 길이가 (r/2)-1인 경우<ul>
<li>해당 지점은 50%의 데미지를 받는 지점이다.</li>
<li>체력이 p/2보다 작은 칸의 개수를 정답으로 세준다.</li>
</ul>
</li>
<li>시작 지점에서부터 어떤 지점까지의 최단 경로 길이가 (r/2)-1보다 큰 경우<ul>
<li>해당 지점은 데미지를 받지 않는 지점이므로 더 이상 탐색을 진행하지 않는다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4번-문제-100-100"><a href="#4번-문제-100-100" class="headerlink" title="4번 문제 (100/100)"></a>4번 문제 (100/100)</h3><ul>
<li>SQL 문제였다.</li>
<li>SQL 문제는 가면 갈수록 어렵게 출제되는 거 같다.</li>
<li>다양한 문제 해결 방법이 있겠지만, 나는 UNION ALL 집합 연산자를 사용해서 문제를 해결했다.</li>
</ul>
<br>

<h2 id="시험-결과"><a href="#시험-결과" class="headerlink" title="시험 결과"></a>시험 결과</h2><img src="/2021/05/11/프로그래머스-2021-여름방학-스타트업-인턴-프로그램-코딩-테스트-후기/pass_email.png" width=650 height=450 alt="합격 이메일" title="합격 이메일" />

<p>코딩 테스트는 턱걸이로 합격할 수 있지 않을까 싶었는데… 만점을 받게 되었다.<br>지금까지 노력했던 게 헛되지 않은 거 같아 기쁘다.<br>코딩 테스트에서 만점 받은 거에 만족하지 않고, 스타트업에서 인턴할 수 있는 기회까지 얻을 수 있도록 면접 준비도 열심히 해야겠다.<br>마지막까지 화이팅!</p>
]]></content>
      <categories>
        <category>시험 후기</category>
      </categories>
      <tags>
        <tag>프로그래머스</tag>
        <tag>코딩 테스트</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 기본 사용법 알아보기</title>
    <url>/2021/06/01/Git-%EA%B8%B0%EB%B3%B8-%EC%82%AC%EC%9A%A9%EB%B2%95-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/</url>
    <content><![CDATA[<h2 id="저장소-만들기"><a href="#저장소-만들기" class="headerlink" title="저장소 만들기"></a>저장소 만들기</h2><p>저장소를 만드는 방법에는 두 가지가 있다.<br>첫 번째 방법은 <code>git init</code> 명령어로 현재 디렉터리에 빈 저장소를 만드는 것이다.   </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/원하는/디렉터리로/이동</span><br><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /현재/위치한/디렉터리/.git/</span><br></pre></td></tr></table></figure>
<p>두 번째 방법은 <code>git clone</code> 명령어로 기존에 있는 저장소를 복제하는 것이다.<br>원격에 있는 저장소를 복제할 수 있고, 로컬에 있는 저장소도 복제할 수 있다.<br>아래는 github에 있는 원격 저장소를 현재 디렉터리에 복제하는 예시이다.   </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/원하는/디렉터리로/이동</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/kihyunkimlee/git-playground.git .</span><br><span class="line">Cloning into <span class="string">&#x27;git-playground&#x27;</span>...</span><br><span class="line">remote: Enumerating objects: 27, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (27/27), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (16/16), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 27 (delta 1), reused 27 (delta 1), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (27/27), <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure>
<p><code>git clone</code> 명령어 뒤에 원격 저장소 주소를 적고 한 칸 뛰고 <code>.</code>를 찍어주지 않으면, 원격 저장소와 같은 이름의 새로운 디렉터리가 생성된 후 그 디렉터리에 복제된다.<br>위의 예시와 같은 경우에는 원격 저장소의 이름이 git-playground이기 때문에 git-playground라는 디렉터리가 생성되고 그 디렉터리에 복제된다.   </p>
<p>아래의 예시처럼 생성될 디렉터리명을 따로 명시해줄 수 있다.   </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/kihyunkimlee/git-playground.git my-playground</span><br></pre></td></tr></table></figure>
<br>

<h2 id="파일의-변경-사항-추적하기"><a href="#파일의-변경-사항-추적하기" class="headerlink" title="파일의 변경 사항 추적하기"></a>파일의 변경 사항 추적하기</h2><p>저장소가 있는 디렉터리의 모든 파일은 크게 untracked 상태와 tracked 상태인 파일로 나눠진다.<br>untracked 상태는 말 그대로 깃에 의해서 관리되지 않는 파일을 뜻한다.<br>tracked 상태는 반대로 깃에 의해서 관리되는 파일을 뜻한다.<br>tracked 상태인 파일의 변경 사항은 깃에 의해서 추적된다.<br><code>git init</code> 명령어로 빈 저장소를 만들고 난 뒤에 디렉터리의 모든 파일은 untracked 상태이다.<br>특정 파일을 tracked 상태로 만들기 위해서는 <code>git add</code> 명령어를 사용해야 한다.   </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add 변경사항을_추적할_파일명</span><br></pre></td></tr></table></figure>
<p>디렉터리의 모든 파일을 tracked 상태로 만들 때는 <code>git add</code>  명령어 다음에 <code>.</code>를 찍어주면 된다.   </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add .</span><br></pre></td></tr></table></figure>
<br>

<h2 id="수정된-파일을-임시-저장소에-저장하기"><a href="#수정된-파일을-임시-저장소에-저장하기" class="headerlink" title="수정된 파일을 임시 저장소에 저장하기"></a>수정된 파일을 임시 저장소에 저장하기</h2><p>수정된 파일을 버전으로 만들고 저장하기 위해서는 먼저 수정된 파일을 임시 저장소에 저장해야 한다.<br>임시 저장소란 무엇이고 왜 있는 걸까?<br>임시 저장소는 하나의 커밋으로 저장될 파일들의 버전을 모아두는 곳이다.<br>임시 저장소가 있기 때문에 수정된 파일들 중에서 원하는 파일만 커밋할 수 있다.   </p>
<p>🚨 <strong>커밋???</strong><br>커밋(Commit)이란 특정 시점의 저장소의 상태이다.<br>특정 시점의 파일의 상태를 버전이라고 한다면, 특정 시점의 저장소의 상태는 커밋이라고 한다.<br>깃은 구글 드라이브나 드롭박스처럼 각 파일의 상태를 관리하지 않는다.<br>깃은 저장소의 상태를 관리한다.<br>그렇기 때문에 깃으로는 원하는 파일만 이전 상태로 되돌릴 수 없다.<br>커밋 안에 포함된 여러 파일들의 상태를 함꺼번에 되돌려야 한다.   </p>
<p><code>git add</code> 명령어는 untracked 상태인 파일을 tracked 상태로 만들 때뿐만 아니라, 변경된 파일을 임시 저장소에 저장할 때도 사용된다.   </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add 임시_저장소에_저장할_파일명</span><br></pre></td></tr></table></figure>
<p><code>git add</code> 명령어로 untracked 상태에서 tracked 상태가 된 파일은 임시 저장소에도 저장된다.   </p>
<br>

<h2 id="임시-저장소에-있는-파일들을-저장소에-저장하기"><a href="#임시-저장소에-있는-파일들을-저장소에-저장하기" class="headerlink" title="임시 저장소에 있는 파일들을 저장소에 저장하기"></a>임시 저장소에 있는 파일들을 저장소에 저장하기</h2><p>임시 저장소에 있는 파일들을 저장소에 저장하면 하나의 커밋이 만들어진다.<br>임시 저장소에 있는 파일들을 저장소에 저장할 때는 <code>git commit</code> 명령어가 사용된다.   </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;Fix minor things&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>git commit</code> 명령어 뒤에 <code>-m</code> 옵션을 붙이면 간단하게 커밋 메시지를 작성할 수 있다.<br>커밋 메시지란 해당 커밋을 설명하는 짧은 설명문이다.<br>커밋을 생성할 때는 반드시 커밋 메시지를 작성해야 한다.   </p>
<br>

<h2 id="다른-커밋으로-시간-여행하기"><a href="#다른-커밋으로-시간-여행하기" class="headerlink" title="다른 커밋으로 시간 여행하기"></a>다른 커밋으로 시간 여행하기</h2><p><code>git log</code> 명령어를 통해서 지금까지 만든 커밋 목록을 확인할 수 있다.   </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit eaad918b867a415cf5c67753838deb1721a304e7 (HEAD -&gt; master, origin/master)</span><br><span class="line">Author: kihyunkimlee &lt;khkh4631@gmail.com&gt;</span><br><span class="line">Date:   Thu May 6 11:04:20 2021 +0900</span><br><span class="line"></span><br><span class="line">    Rename folder</span><br><span class="line"></span><br><span class="line">commit 8110c8e5d19a760b789adae295deb4b282fcf71c (old_git_playground/master)</span><br><span class="line">Author: kihyunkimlee &lt;khkh4631@gmail.com&gt;</span><br><span class="line">Date:   Thu May 6 10:59:17 2021 +0900</span><br><span class="line"></span><br><span class="line">    Add test.json</span><br><span class="line"></span><br><span class="line">&lt;이하 생략&gt;</span><br></pre></td></tr></table></figure>
<p>만약에 2021년 5월 6일 10시 59분 17초에 만들었던 커밋(커밋 아이디 앞 7자리가 8110c8e인 커밋)으로 잠깐 되돌아가고 싶다면 <code>git checkout</code>명령어를 사용하면 된다.   </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout 8110c8e</span><br></pre></td></tr></table></figure>
<p>다시 원래대로 되돌리고 싶으면 아래와 같은 명령어를 실행하면 된다.   </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>네트워크에서 발생하는 지연</title>
    <url>/2021/06/02/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EC%97%90%EC%84%9C-%EB%B0%9C%EC%83%9D%ED%95%98%EB%8A%94-%EC%A7%80%EC%97%B0/</url>
    <content><![CDATA[<h2 id="네트워크에서-발생하는-지연"><a href="#네트워크에서-발생하는-지연" class="headerlink" title="네트워크에서 발생하는 지연"></a>네트워크에서 발생하는 지연</h2><ul>
<li>네트워크에서 발생하는 지연 시간을 분석하기 위해서는 한 노드에서 다른 노드로 패킷을 전송할 때 발생할 수 있는 다양한 지연에 대해서 알고 있어야 한다.</li>
<li>WHY???<ul>
<li>패킷은 출발지 호스트에서 시작해서 일련의 라우터들을 거쳐서 목적지 호스트로 전달된다.</li>
<li>그러므로 패킷이 출발지에서 목적지로 전달되는 과정은 한 노드(호스트 또는 라우터)에서 다른 노드(호스트 또는 라우터)로 전달되는 과정의 연속이라고 할 수 있다.</li>
<li>패킷이 전달되는 경로상의 각 노드에서 발생하는 지연 시간의 합은 패킷이 출발지에서 목적지로 전달되는 데 걸리는 시간과 거의 같을 것이다.</li>
<li>그러므로 한 노드에서 다른 노드로 패킷을 전송할 때 발생할 수 있는 다양한 지연에 대해서 알고 있으면, 네트워크에서 발생하는 지연 시간을 분석할 수 있을 것이다.</li>
</ul>
</li>
<li>한 노드에서 다른 노드로 패킷을 전송할 때 발생하는 지연에는 대표적으로 <strong>처리 지연</strong>과 <strong>큐잉 지연</strong>, <strong>전송 지연</strong>, 그리고 <strong>전파 지연</strong>이 있다.</li>
</ul>
<br>

<h2 id="처리-지연"><a href="#처리-지연" class="headerlink" title="처리 지연"></a>처리 지연</h2><ul>
<li>패킷 헤더를 조사해서 그 패킷을 어디로 보낼지를 결정하는 데 걸리는 시간.</li>
<li>라우터나 스위치에서 발생한다.</li>
<li>고속 라우터에서의 처리 지연은 일반적으로 수 마이크로초라고 한다.</li>
</ul>
<br>

<h2 id="큐잉-지연"><a href="#큐잉-지연" class="headerlink" title="큐잉 지연"></a>큐잉 지연</h2><ul>
<li>패킷이 라우터에 도착하고 어떤 링크로 출력되기 전까지 출력 버퍼에서 대기하고 있는 시간.</li>
<li>출력 버퍼???<ul>
<li>라우터의 링크마다 존재하는 패킷 임시 저장소.</li>
<li>도착한 패킷이 어떤 한 링크로 전송되어야 하는데 그 링크가 다른 패킷을 전송하고 있다면, 도착한 패킷은 해당 링크의 출력 버퍼에서 대기하게 된다.</li>
<li>출력 버퍼가 가득 차게 되면 패킷 손실이 발생할 수 있다.</li>
<li>패킷 손실???<ul>
<li>출력 버퍼가 전송을 위해 대기 중인 다른 패킷들로 가득 차게 되면, 라우터는 그 이후에 도착한 패킷이나 기존에 출력 버퍼에 있는 패킷들을 폐기한다.</li>
<li>이때 폐기된 패킷은 목적지 호스트에 도착하지 못하고 네트워크 중간에서 소멸되기 때문에 패킷 손실이 일어났다고 한다.</li>
</ul>
</li>
</ul>
</li>
<li>큐잉 지연은 네트워크 트래픽의 강도와 특성에 따라 달라진다.</li>
</ul>
<br>

<h2 id="전송-지연"><a href="#전송-지연" class="headerlink" title="전송 지연"></a>전송 지연</h2><ul>
<li>패킷의 모든 비트를 출력 링크로 내보내는 데 걸리는 시간.</li>
<li>패킷의 크기가 L 비트이고 출력 링크의 전송률이 R bps 일 때, 전송 지연 시간은 L/R 초가 된다.</li>
<li>WHY???<ul>
<li>인터넷은 회선(circuit) 교환 방식 네트워크가 아니라 패킷 교환 방식 네트워크이다.</li>
<li>패킷 교환 방식 네트워크에서 패킷은 출력 링크의 최대 전송 속도와 같은 속도로 링크에 전송되어 진다.</li>
<li>출력 링크의 전송률이 R bps라면 해당 링크는 초당 R 비트의 데이터를 전송할 수 있다는 뜻이다.</li>
<li>그러므로 L 비트 크기의 패킷을 전송률이 R bps인 링크로 전송하는 데 걸리는 시간은 L/R 초이다.</li>
</ul>
</li>
<li>(라우터의 전송률과 출력 링크의 전송률이 달라도 정상 동작할까…?)</li>
</ul>
<br>

<h2 id="전파-지연"><a href="#전파-지연" class="headerlink" title="전파 지연"></a>전파 지연</h2><ul>
<li>한 노드에서 전송한 비트가 링크를 통해서 다른 노드로 전달되는 데 걸리는 시간.</li>
<li>전파 지연 시간은 링크의 전파 속도와 물리적 길이에 따라서 결정된다.</li>
<li>전파 속도는 링크의 물리 매체에 따라 다르지만 대략 빛의 속도와 같거나 약간 작다.</li>
<li>링크의 전파 속도가 S m/s이고 링크의 길이가 D 미터일 때, 전파 지연 시간은 D/S 초가 된다.</li>
<li>광역 네트워크에서 전파 지연은 일반적으로 수 초에 이른다고 한다.</li>
</ul>
]]></content>
      <categories>
        <category>컴퓨터과학</category>
        <category>네트워크</category>
      </categories>
      <tags>
        <tag>네트워크 지연</tag>
        <tag>네트워크</tag>
      </tags>
  </entry>
</search>
